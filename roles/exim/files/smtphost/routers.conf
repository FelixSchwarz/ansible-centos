######################################################################
#     THE ORDER IN WHICH THE ROUTERS ARE DEFINED IS IMPORTANT!       #
# An address is passed to each router in turn until it is accepted.  #
######################################################################

# This router routes addresses that are not in local domains by doing a DNS
# lookup on the domain name. The exclamation mark that appears in "domains = !
# +local_domains" is a negating operator, that is, it can be read as "not". The
# recipient's domain must not be one of those defined by "domainlist
# local_domains" above for this router to be used.
#
# If the router is used, any domain that resolves to 0.0.0.0 or to a loopback
# interface address (127.0.0.0/8) is treated as if it had no DNS entry. Note
# that 0.0.0.0 is the same as 0.0.0.0/32, which is commonly treated as the
# local host inside the network stack. It is not 0.0.0.0/0, the default route.
# If the DNS lookup fails, no further routers are tried because of the no_more
# setting, and consequently the address is unrouteable.
dnslookup:
  driver = dnslookup
  domains = ! +local_domains
  transport = remote_smtp
  ignore_target_hosts = 0.0.0.0 : 127.0.0.0/8
  no_more


dovecot_aliases:
  driver = redirect
  domains = +local_domains
  data = ${lookup sqlite{USERDB \
        select target_address from aliases where domain="$domain" and local_part="$local_part"; \
  }}
  # This allows just to store a localpart (e.g. "admin") as an alias for 
  # xyz@domain.example (instead of the explicitadmin@domain.example)
  qualify_preserve_domain
  # enable '+' addressing (foo+bar@example.com) so I can easily add more email
  # addresses without creating aliases (e.g. for bitbucket team accounts).
  local_part_suffix = +*
  local_part_suffix_optional


system_aliases:
  driver = redirect
  # only check system aliases for 'name of the local host' (@) and 'localhost'
  # root@<maildomain> should not be resolved here...
  domains = @ : localhost
  allow_fail
  allow_defer
  data = ${lookup{$local_part}lsearch{/etc/aliases}}


dovecot_users:
  driver = accept
  domains = +local_domains
  local_parts = sqlite;USERDB select local_part from users where domain="$domain" and local_part="$local_part";
  transport = dovecot
  # enable '+' addressing (foo+bar@example.com) so I can easily add more email
  # addresses without creating aliases (e.g. for bitbucket team accounts).
  local_part_suffix = +*
  local_part_suffix_optional

