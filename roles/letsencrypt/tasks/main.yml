---

- set_fact: hostname_letsencrypt={{ letsencrypt_host_domains[0] }}
  when: use_letsencrypt_cert

- name: install letsencrypt package
  yum: name={{ item }} state=present
  with_items:
    - letsencrypt

# needed to for acme challenges
- name: open port 80 in the firewall
  firewalld: port=80/tcp permanent=true immediate=true state=enabled
  when: use_letsencrypt_cert

# /etc/letsencrypt is owned by the letsencrypt rpm but only created when the
# program is executed for the first time. I'd like to put the client.ini in
# /etc/letsencrypt (see below) so we need to create the directory first.
- name: create /etc/letsencrypt
  file: path=/etc/letsencrypt state=directory owner=root group=root mode=0755

# jinja2 template so we can have a dynamic admin email address
- name: generate client.ini
  template: src=letsencrypt.ini.j2 dest={{ letsencrypt_ini_path }} owner=root group=root mode=0640

# ,--- prepare webroot-based authentication ------------------------------------
- name: create /srv/letsencrypt
  file: path=/srv/letsencrypt state=directory mode=0755

# create a fake webroot where we can point to in the letsencrypt ini
- name: create /srv/letsencrypt/fake-webroot
  file: path=/srv/letsencrypt/fake-webroot state=directory mode=0755

- name: create fake-webroot/.well-known
  file: path=/srv/letsencrypt/fake-webroot/.well-known state=directory mode=0755

- name: create fake-webroot/.well-known
  file: path=/srv/letsencrypt/fake-webroot/.well-known state=directory mode=0755

# mode=0755: I think the acme-challenge should not contain sensitive
# information - in the end they are transmitted with plain HTTP anyway...
- name: create fake-webroot/.well-known/acme-challenge
  file: path=/srv/letsencrypt/fake-webroot/.well-known/acme-challenge state=directory mode=0755

# `--- prepare webroot-based authentication ------------------------------------

- name: check if host already has a letsencrypt cert
  stat: path=/etc/letsencrypt/live/{{ hostname_letsencrypt }}/fullchain.pem
  when: use_letsencrypt_cert
  register: letsencrypt_hostcert

# There is a bit of a "gotcha" here: The webserver needs a certificate when its
# configured+started by ansible (so we don't have to resort to complicated
# config changes depending on the letsencrypt change). Using a web server also
# means we need to use the "webroot" authenticator - which isn't possible
# without a running webserver...
#
# So we check first if a webserver is running on port 80. If it is just use
# the "webroot" authentication method (assumes the server is configured to use
# our global "/srv/letsencrypt/acme-challenge" directory).
# Otherwise use the "standalone" authenticator and patch the renewal settings
# (in /etc/letsencrypt/renewal/....conf) dynamically in the webserver role.

- name: Check if webserver is running on port 80
  # we pipe through "cat" at the end because grep will set its exit code to "1"
  # if no input matched (leading to a ansible task error). cat will just return
  # exit code 0 in all cases.
  shell: /usr/bin/netstat -tulpen | grep ":80 " | cat
  register: listening_services_for_http

# unfortunately I was unable to test for the length of stdout_lines (likely due
# to one of the various jinja2 limitations and/or my own stupidity so just
# compare to empty list explicitly ("[]").
- set_fact:
    is_http_server_running: "{{ (listening_services_for_http.stdout_lines == []) | ternary('false', 'true') }}"

- set_fact:
    letsencrypt_authenticator: "{{ (is_http_server_running and (not standalone_authenticator_only)) | ternary('webroot', 'standalone') }}"

- name: generate letsencrypt host cert
  shell: letsencrypt certonly --{{ letsencrypt_authenticator }} --config {{ letsencrypt_ini_path }} -d {{ letsencrypt_host_domains | join(' -d ') }}
  when: use_letsencrypt_cert and (letsencrypt_hostcert.stat.exists == False)


- name: change letsencrypt authenticator settings to webroot
  lineinfile: >
    dest="/etc/letsencrypt/renewal/{{ hostname_letsencrypt }}.conf"
    regexp="^authenticator\s*=\s*.+"
    line="authenticator = webroot"
  when: use_letsencrypt_cert and (not is_http_server_running) and (not standalone_authenticator_only)

- name: change letsencrypt authenticator settings to webroot
  lineinfile: >
    dest="/etc/letsencrypt/renewal/{{ hostname_letsencrypt }}.conf"
    regexp="^webroot_path\s*=\s*.+"
    line="webroot_path = /srv/letsencrypt/fake-webroot"
  when: use_letsencrypt_cert and (not is_http_server_running) and (not standalone_authenticator_only)

