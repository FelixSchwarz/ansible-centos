# This file is managed by Ansible. Don't make changes here, they will be overwritten.

# check syntax:
# exim -C /etc/exim/exim.conf -bV

.include_if_exists  /etc/exim/local.conf
USERDB=/srv/mail/userdb.sqlite

domainlist local_domains = \
    sqlite;USERDB select DISTINCT domain from users where domain="$domain"; : \
    sqlite;USERDB select DISTINCT domain from aliases where domain="$domain"; :
domainlist relay_to_domains =
hostlist   relay_from_hosts = 127.0.0.1 : ::::1/128

acl_smtp_mail = acl_check_mail
acl_smtp_rcpt = acl_check_rcpt
acl_smtp_data = acl_check_data
acl_smtp_mime = acl_check_mime

tls_advertise_hosts = *
tls_certificate = /etc/exim/tls/fullchain.pem
tls_privatekey = /etc/exim/tls/privkey.pem

daemon_smtp_ports = 25 : 587

# qualify_domain =
never_users = root
host_lookup = 
rfc1413_hosts = 
auth_advertise_hosts = ${if eq {$tls_cipher}{}{}{*}}

ignore_bounce_errors_after = 2d
timeout_frozen_after = 7d

# prevent Exim warning "WARNING: purging the environment." (related to CVE-2016-1531)
keep_environment =

######################################################################
#                       ACL CONFIGURATION                            #
#         Specifies access control lists for incoming SMTP mail      #
######################################################################

begin acl
acl_check_mail:
  # Hosts are required to say HELO (or EHLO) before sending mail.
  # So don't allow them to use the MAIL command if they haven't
  # done so.
  deny condition = ${if eq{$sender_helo_name}{} {1}}
       message = Nice boys say HELO first

  # Use the lack of reverse DNS to trigger greylisting. Some people
  # even reject for it but that would be a little excessive.
  warn condition = ${if eq{$sender_host_name}{} {1}}
       set acl_m_greylistreasons = Host $sender_host_address lacks reverse DNS\n$acl_m_greylistreasons

  accept



# This access control list is used for every RCPT command in an incoming
# SMTP message. The tests are run in order until the address is either
# accepted or denied.

acl_check_rcpt:
  # Accept if the source is local SMTP (i.e. not over TCP/IP). We do this by
  # testing for an empty sending host field.
  accept  hosts = :
          control = dkim_disable_verify

  deny    message       = connections to port 587 require authentication
          condition     = ${if eq{$interface_port}{587}{1}{0}}
          !authenticated = *

  deny    message       = Restricted characters in address
          domains       = +local_domains
          local_parts   = ^[.] : ^.*[@%!/|]

  deny    message       = Restricted characters in address
          domains       = !+local_domains
          local_parts   = ^[./|] : ^.*[@%!] : ^.*/\\.\\./

  # Deny unless the sender address can be routed. For proper verification of the
  # address, read the documentation on callouts and add the /callout modifier.
  require verify        = sender

  accept  hosts         = +relay_from_hosts
          control       = submission
          control       = dkim_disable_verify

  # Accept if the message arrived over an authenticated connection, from any host.
  accept  authenticated = *
          control       = submission/sender_retain
          control       = dkim_disable_verify

  require message = relay not permitted
          domains = +local_domains : +relay_to_domains

  # We also require all accepted addresses to be verifiable. This check will
  # do local part verification for local domains, but only check the domain
  # for remote domains. The only way to check local parts for the remote
  # relay domains is to use a callout (add /callout), but please read the
  # documentation about callouts before doing this.
  require verify = recipient

  # At this point, the address has passed all the checks that have been
  # configured, so we accept it unconditionally.
  accept


acl_check_data:
  # RFC2822 says a Message-Id: header SHOULD be present - trigger greylisting if not
  warn    condition  = ${if !def:h_Message-ID: {1}}
          set acl_m_greylistreasons = Message lacks Message-Id: header. Consult RFC2822.\n$acl_m_greylistreasons

 accept


acl_check_mime:
  # File extension filtering.
  deny message = Blacklisted file extension detected
       condition = ${if match \
                        {${lc:$mime_filename}} \
                        {\N(\.exe|\.pif|\.bat|\.scr|\.lnk|\.com)$\N} \
                     {1}{0}}

  accept


######################################################################
#                      ROUTERS CONFIGURATION                         #
#               Specifies how addresses are handled                  #
######################################################################
#     THE ORDER IN WHICH THE ROUTERS ARE DEFINED IS IMPORTANT!       #
# An address is passed to each router in turn until it is accepted.  #
######################################################################

begin routers
# This router routes addresses that are not in local domains by doing a DNS
# lookup on the domain name. The exclamation mark that appears in "domains = !
# +local_domains" is a negating operator, that is, it can be read as "not". The
# recipient's domain must not be one of those defined by "domainlist
# local_domains" above for this router to be used.
#
# If the router is used, any domain that resolves to 0.0.0.0 or to a loopback
# interface address (127.0.0.0/8) is treated as if it had no DNS entry. Note
# that 0.0.0.0 is the same as 0.0.0.0/32, which is commonly treated as the
# local host inside the network stack. It is not 0.0.0.0/0, the default route.
# If the DNS lookup fails, no further routers are tried because of the no_more
# setting, and consequently the address is unrouteable.

dnslookup:
  driver = dnslookup
  domains = ! +local_domains
  transport = remote_smtp
  ignore_target_hosts = 0.0.0.0 : 127.0.0.0/8
  no_more


dovecot_aliases:
  driver = redirect
  domains = +local_domains
  data = ${lookup sqlite{USERDB \
        select target_address from aliases where domain="$domain" and local_part="$local_part"; \
  }}
  # This allows just to store a localpart (e.g. "admin") as an alias for 
  # xyz@domain.example (instead of the explicitadmin@domain.example)
  qualify_preserve_domain
  # enable '+' addressing (foo+bar@example.com) so I can easily add more email
  # addresses without creating aliases (e.g. for bitbucket team accounts).
  local_part_suffix = +*
  local_part_suffix_optional


system_aliases:
  driver = redirect
  # only check system aliases for 'name of the local host' (@) and 'localhost'
  # root@<maildomain> should not be resolved here...
  domains = @ : localhost
  allow_fail
  allow_defer
  data = ${lookup{$local_part}lsearch{/etc/aliases}}


dovecot_users:
  driver = accept
  domains = +local_domains
  local_parts = sqlite;USERDB select local_part from users where domain="$domain" and local_part="$local_part";
  transport = dovecot
  # enable '+' addressing (foo+bar@example.com) so I can easily add more email
  # addresses without creating aliases (e.g. for bitbucket team accounts).
  local_part_suffix = +*
  local_part_suffix_optional



######################################################################
#                      TRANSPORTS CONFIGURATION                      #
######################################################################
#                       ORDER DOES NOT MATTER                        #
#     Only one appropriate transport is called for each delivery.    #
######################################################################

# A transport is used only when referenced from a router that successfully
# handles an address.

begin transports

remote_smtp:
  driver = smtp
  dkim_selector = x
  # if
  #   (submitted from local system OR user is authenticated)
  #   AND
  #   /etc/exim/dkim/[sender domain].key exists
  #
  #   !def:sender_host_address    sender_host_address is empty for localhost => 'def:...' returns False
  #   def:authenticated_id        authenticated_id is empty for anonymous sending => 'def:...' as above
  #
  # "dkim_private_key = false" means sending unsigned mails ("just skip DKIM")
  # As per Exim spec this is not considered a signature "failure" so it works
  # even with "dkim_strict = true"
  dkim_domain = $sender_address_domain
  dkim_private_key = ${if \
    and { \ 
      { or { {!def:sender_host_address}{def:authenticated_id} } } \
      { exists{/etc/exim/dkim/${dkim_domain}_${dkim_selector}.key} } \
    } \
    {/etc/exim/dkim/${dkim_domain}_${dkim_selector}.key}{false} \
  }
  # if message signing fails, defer message delivery
  dkim_strict = true


dovecot:
  driver = pipe
  # -e will prevent rejection mails from dovecot, let Exim do that instead!
  command = /usr/libexec/dovecot/dovecot-lda \
    -a $original_local_part@$original_domain \
    -d $local_part@$domain \
    -f $sender_address \
    -e
  message_prefix =
  message_suffix =
  delivery_date_add
  envelope_to_add
  return_path_add
  log_output
  user = mail
  temp_errors = 64 : 69 : 70: 71 : 72 : 73 : 74 : 75 : 78

######################################################################
#                      RETRY CONFIGURATION                           #
######################################################################

begin retry

# This single retry rule applies to all domains and all errors. It specifies
# retries every 15 minutes for 2 hours, then increasing retry intervals,
# starting at 1 hour and increasing each time by a factor of 1.5, up to 16
# hours, then retries every 6 hours until 4 days have passed since the first
# failed delivery.

# WARNING: If you do not have any retry rules at all (this section of the
# configuration is non-existent or empty), Exim will not do any retries of
# messages that fail to get delivered at the first attempt. The effect will
# be to treat temporary errors as permanent. Therefore, DO NOT remove this
# retry rule unless you really don't want any retries.

# Address or Domain    Error       Retries
# -----------------    -----       -------

*                      *           F,2h,15m; G,16h,1h,1; F,3d,6h



######################################################################
#                      REWRITE CONFIGURATION                         #
######################################################################

# There are no rewriting specifications in this default configuration file.

begin rewrite

.include_if_exists /etc/exim/rewrite.conf

######################################################################
#                   AUTHENTICATION CONFIGURATION                     #
######################################################################

begin authenticators

dovecot_plain:
  driver = dovecot
  public_name = PLAIN
  server_socket = /var/run/dovecot/auth-client
  server_set_id = $auth1
  server_advertise_condition = ${if def:tls_cipher }

dovecot_login:
  driver = dovecot
  public_name = LOGIN
  server_socket = /var/run/dovecot/auth-client
  server_set_id = $auth1
  server_advertise_condition = ${if def:tls_cipher }

# End of Exim configuration file

